def self.evaluate(expression)

		formatted_data = format(TagExpressions::Parse::tuples_from_string(expression))
		tags = formatted_data[:tags]; operators_list = formatted_data[:operators_list]
		
		return_list = []

		# iterate sublists of operators (or tags)
		operators_list.each_with_index do |operators, operators_index|

			sets = Array.new(tags[operators_index].length){|set_index| data[tags[operators_index][set_index]]}
			indices = Array.new(tags[operators_index].length){ 0}
			i = 0

			# iterate until you accumulate your total OR you reach the end of your reference set 
			# increment i each iteration
			while return_list.length < ACCUMULATE and (i < sets[0].length)

				reference = sets[0][i]

				# for each increment along the reference set, we must advance all the sub sets
				# advance until the current index is NOT greater than the reference 
				sets.each_with_index do |set, j|

					if reference != nil and indices[j] < sets[j].length and sets[j][indices[j]] > reference
						while (sets[j][indices[j]] != nil and sets[j][indices[j]] > reference)
							indices[j] +=1
						end
					end
				end

				# after advancing the sub sets, we can check their conditions as described in check_condition
				if condition(sets, indices, operators, reference) == true
					if reference != nil
						return_list.push(reference)
					elsif sets[0][i] != nil 
						return_list.push(sets[0][i]) # then all remaining from set_0 must be diffs
					end
				end
				
				i += 1
			end
		end
		return return_list.sort{|a,b| b<=>a}.uniq
	end
end